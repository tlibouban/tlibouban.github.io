/**
 * triStateManager.js - Gestion des switches tri-state
 * √âtats : rouge (non examin√©) ‚Üí bleu croix (√©cart√©) ‚Üí vert (activ√©)
 */

// Variables globales pour les compteurs
let triStateCounters = {
  notExamined: 0,
  rejected: 0,
  activated: 0,
};

/**
 * G√©n√®re un switch tri-state pour remplacer les switches binaires
 * @param {string} id - ID unique pour le switch
 * @param {string} name - Nom du champ
 * @param {string} initialState - √âtat initial (not-examined, rejected, activated)
 * @param {string} ariaLabel - Label d'accessibilit√©
 * @param {string} cssClass - Classe CSS additionnelle
 * @returns {string} HTML du switch tri-state
 */
function renderTriStateSwitch(
  id,
  name,
  initialState = "not-examined",
  ariaLabel = "",
  cssClass = "check-feature"
) {
  const stateClasses = {
    "not-examined": "",
    rejected: "rejected",
    activated: "activated",
  };

  const stateClass = stateClasses[initialState] || "";

  return `
        <div class="tri-state-modern-container">
            <div class="tri-state-modern-switch ${stateClass}" 
                 data-id="${id}"
                 data-name="${name}"
                 data-state="${initialState}"
                 data-css-class="${cssClass}"
                 aria-label="${ariaLabel}"
                 tabindex="0"
                 role="button"
                 onclick="cycleTriState(this)">
                <div class="tri-state-tick-mark"></div>
                <span class="cross-icon">‚ùå</span>
            </div>
        </div>
    `;
}

/**
 * Cycle entre les √©tats du switch tri-state
 * @param {HTMLElement} element - √âl√©ment du switch
 */
function cycleTriState(element) {
  const currentState = element.getAttribute("data-state");
  let newState;

  // Cycle : non examin√© ‚Üí √©cart√© ‚Üí activ√© ‚Üí non examin√©
  switch (currentState) {
    case "not-examined":
      newState = "rejected";
      break;
    case "rejected":
      newState = "activated";
      break;
    case "activated":
      newState = "not-examined";
      break;
    default:
      newState = "not-examined";
  }

  // Mettre √† jour l'√©tat
  setTriStateState(element, newState);

  // Mettre √† jour les totaux
  updateTotals();
  updateTriStateCounters();
}

/**
 * D√©finit l'√©tat d'un switch tri-state
 * @param {HTMLElement} element - √âl√©ment du switch
 * @param {string} state - Nouvel √©tat
 */
function setTriStateState(element, state) {
  // Supprimer toutes les classes d'√©tat
  element.classList.remove("rejected", "activated");

  // Ajouter la nouvelle classe d'√©tat
  if (state !== "not-examined") {
    element.classList.add(state);
  }

  // Mettre √† jour l'attribut data-state
  element.setAttribute("data-state", state);
}

/**
 * Obtient l'√©tat d'un switch tri-state
 * @param {HTMLElement} element - √âl√©ment du switch
 * @returns {string} √âtat actuel
 */
function getTriStateState(element) {
  return element.getAttribute("data-state") || "not-examined";
}

/**
 * V√©rifie si un switch tri-state est activ√© (pour les calculs)
 * @param {HTMLElement} element - √âl√©ment du switch
 * @returns {boolean} True si activ√©
 */
function isTriStateActivated(element) {
  return getTriStateState(element) === "activated";
}

/**
 * Met √† jour les compteurs tri-state
 */
function updateTriStateCounters() {
  // R√©initialiser les compteurs
  triStateCounters = {
    notExamined: 0,
    rejected: 0,
    activated: 0,
  };

  // Compter tous les switches tri-state
  document.querySelectorAll(".tri-state-modern-switch").forEach((sw) => {
    const state = getTriStateState(sw);
    switch (state) {
      case "not-examined":
        triStateCounters.notExamined++;
        break;
      case "rejected":
        triStateCounters.rejected++;
        break;
      case "activated":
        triStateCounters.activated++;
        break;
    }
  });

  // Mettre √† jour l'affichage
  updateFloatingStatsDisplay();
}

/**
 * Met √† jour l'affichage de la bo√Æte flottante
 */
function updateFloatingStatsDisplay() {
  const elements = {
    "floating-count-not-examined": triStateCounters.notExamined,
    "floating-count-rejected": triStateCounters.rejected,
    "floating-count-activated": triStateCounters.activated,
  };

  Object.entries(elements).forEach(([id, count]) => {
    const element = document.getElementById(id);
    if (element) {
      element.textContent = count;
    }
  });
}

/**
 * Cr√©e la bo√Æte flottante des compteurs
 */
function createFloatingStats() {
  const floatingHTML = `
        <div class="floating-stats" id="floating-stats">
            <h3>üìä Fonctionnalit√©s</h3>
            
            <div class="floating-stat-item floating-stat-not-examined">
                <span>‚ùì Non examin√©es</span>
                <span class="floating-stat-number" id="floating-count-not-examined">0</span>
            </div>
            
            <div class="floating-stat-item floating-stat-rejected">
                <span>‚ùå √âcart√©es</span>
                <span class="floating-stat-number" id="floating-count-rejected">0</span>
            </div>
            
            <div class="floating-stat-item floating-stat-activated">
                <span>‚úÖ Activ√©es</span>
                <span class="floating-stat-number" id="floating-count-activated">0</span>
            </div>
            
            <div class="floating-controls">
                <button class="floating-btn" onclick="bulkSetTriStateNotExamined()" title="Marquer tout comme non examin√©">
                    üîÑ Reset
                </button>
                <button class="floating-btn" onclick="bulkSetTriStateActivated()" title="Activer toutes les fonctionnalit√©s √©cart√©es">
                    ‚úÖ Activer √©cart√©es
                </button>
            </div>
        </div>
    `;

  // Ajouter au body
  document.body.insertAdjacentHTML("beforeend", floatingHTML);
}

/**
 * Actions en lot pour les switches tri-state
 */
function bulkSetTriStateNotExamined() {
  document.querySelectorAll(".tri-state-modern-switch").forEach((sw) => {
    setTriStateState(sw, "not-examined");
  });
  updateTotals();
  updateTriStateCounters();
}

function bulkSetTriStateActivated() {
  document.querySelectorAll(".tri-state-modern-switch").forEach((sw) => {
    const currentState = getTriStateState(sw);
    if (currentState === "rejected") {
      setTriStateState(sw, "activated");
    }
  });
  updateTotals();
  updateTriStateCounters();
}

/**
 * Gestion du clavier pour l'accessibilit√©
 */
function initTriStateKeyboardHandlers() {
  document.addEventListener("keydown", function (event) {
    if (event.target.classList.contains("tri-state-modern-switch")) {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        cycleTriState(event.target);
      }
    }
  });
}

/**
 * Initialisation du syst√®me tri-state
 */
function initTriStateSystem() {
  // Cr√©er la bo√Æte flottante
  createFloatingStats();

  // Initialiser les gestionnaires de clavier
  initTriStateKeyboardHandlers();

  // Compter initial
  updateTriStateCounters();

  console.log("üéØ Syst√®me tri-state initialis√©");
}

// Initialiser d√®s que le DOM est pr√™t
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", initTriStateSystem);
} else {
  initTriStateSystem();
}
